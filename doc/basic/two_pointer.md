# 双指针问题

维护任意端点为起点或终点, 所对应的满足题目需求的区间, 时间复杂度在o(n).

## 问题性质

待补充.

## 常见的 扩展/收缩 区间

区间用左闭右闭[st, ed]表示.

st: tail, delete操作.

ed: head, add操作.

1. 固定st, ed中ok条件.

2. 固定ed, st中not ok条件.

写法表现为2重循环, 固定的端点在外层循环, 需要扩展的端点在内层循环.
因为多种写法不统一, 所以这里不放框架了, 以下请自行想象代码的实现(之后写多了, 我可能会总结一下各种写法).

循环方向可以有2个方向, 甚至是循环位移.

注意区间端点性质:

循环从小到大, 有`st <= ed`.  
循环从大到小, 有`ed <= st`.  
循环位移同理, 但是可能判定有点复杂, 遇到了再说(下次一定).

不管什么循环, st都是在ed后面的, 保证区间长度至少为1(当然可能这1个也不满足条件, 那么这时候区间长度就是0了).

---

以下假设循环是从小到大的.

考虑st可能超过ed的情况, 也就是某个区间无解的情况.

情况1, st的速度快于ed(因为ed是条件变化), 需要让慢的ed强制至少和st同步,  
为了满足区间约束, 那么我们需要`ed = max(ed, st)`, 即强制复位不合法的区间端点.

情况2则不会出现st会超过ed的情况(因为st是条件变化).

简单来说可以在每次操作区间之前强制st和ed满足`st <= ed`的关系, 即维护st在ed后面的性质.

以上结论是参考cf1409e得到的, 不一定完全正确.

### 小结

#### 要素

1. 区间端点左闭右闭.

2. 方向明确.

3. 2重循环, 固定点在外层循环, 条件点在内层循环.

4. 内层循环开始前, 可以强制复位不合法的区间端点.

5. 答案一般是区间的长度, 或者是端点加减的函数维护了答案.

6. 答案记录在固定点下标.

## 游程编码

数组的相邻的数之间保持某种(可传递的)关系, 把相同性质的段落分隔开来, 类似字符串中的strtok.

其中, (可传递的)关系有可能是以下几种(也可能有别的但是这里没有列出来):

1. 相等.
2. 升序.
3. 降序.

当然, 也可能不是相邻的关系, 可能是像分段函数一样刻意定义的映射, 并不存在相邻的关系.

因为是划分段落, 所以区间就不是以一个单位来扩展了, 是扫描一段之后跳转到下一段, 过程有点类似字符串匹配.

以终点做外层循环, 会比较好实现.  
以关系是相等为例, 框架如下:

```c++
vector<int> da;
int st = 0;
for (int ed = 0; ed < da.size(); ++ed) {
    if (ed == da.size() - 1 || da[ed] != da[ed + 1]) {
        calc(st, ed);
        st = ed + 1;
    }
}
```

